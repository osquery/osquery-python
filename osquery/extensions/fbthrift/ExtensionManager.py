#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


from osquery.extensions import Extension
from .ttypes import *
from thrift.Thrift import TProcessor
import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastproto
except:
  fastproto = None

all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

from thrift.util.Decorators import *

class Iface(Extension.Iface):
  def extensions(self, ):
    pass

  def options(self, ):
    pass

  def registerExtension(self, info=None, registry=None):
    """
    Parameters:
     - info
     - registry
    """
    pass

  def deregisterExtension(self, uuid=None):
    """
    Parameters:
     - uuid
    """
    pass

  def query(self, sql=None):
    """
    Parameters:
     - sql
    """
    pass

  def getQueryColumns(self, sql=None):
    """
    Parameters:
     - sql
    """
    pass


class ContextIface(Extension.ContextIface):
  def extensions(self, handler_ctx, ):
    pass

  def options(self, handler_ctx, ):
    pass

  def registerExtension(self, handler_ctx, info=None, registry=None):
    """
    Parameters:
     - info
     - registry
    """
    pass

  def deregisterExtension(self, handler_ctx, uuid=None):
    """
    Parameters:
     - uuid
    """
    pass

  def query(self, handler_ctx, sql=None):
    """
    Parameters:
     - sql
    """
    pass

  def getQueryColumns(self, handler_ctx, sql=None):
    """
    Parameters:
     - sql
    """
    pass


# HELPER FUNCTIONS AND STRUCTURES

class extensions_args:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('extensions_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(extensions_args)
extensions_args.thrift_spec = (
)

extensions_args.thrift_struct_annotations = {
}
extensions_args.thrift_field_annotations = {
}

class extensions_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype40, _vtype41, _size39 ) = iprot.readMapBegin() 
          if _size39 >= 0:
            for _i43 in six.moves.range(_size39):
              _key44 = iprot.readI64()
              _val45 = InternalExtensionInfo()
              _val45.read(iprot)
              self.success[_key44] = _val45
          else: 
            while iprot.peekMap():
              _key46 = iprot.readI64()
              _val47 = InternalExtensionInfo()
              _val47.read(iprot)
              self.success[_key46] = _val47
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('extensions_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter48,viter49 in self.success.items():
        oprot.writeI64(kiter48)
        viter49.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(extensions_result)
extensions_result.thrift_spec = (
  (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,[InternalExtensionInfo, InternalExtensionInfo.thrift_spec, False]), None, 2, ), # 0
)

extensions_result.thrift_struct_annotations = {
}
extensions_result.thrift_field_annotations = {
}

def extensions_result__init__(self, success=None,):
  self.success = success

extensions_result.__init__ = extensions_result__init__

class options_args:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('options_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(options_args)
options_args.thrift_spec = (
)

options_args.thrift_struct_annotations = {
}
options_args.thrift_field_annotations = {
}

class options_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype51, _vtype52, _size50 ) = iprot.readMapBegin() 
          if _size50 >= 0:
            for _i54 in six.moves.range(_size50):
              _key55 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val56 = InternalOptionInfo()
              _val56.read(iprot)
              self.success[_key55] = _val56
          else: 
            while iprot.peekMap():
              _key57 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val58 = InternalOptionInfo()
              _val58.read(iprot)
              self.success[_key57] = _val58
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('options_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter59,viter60 in self.success.items():
        oprot.writeString(kiter59.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter59, bytes) else oprot.writeString(kiter59)
        viter60.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(options_result)
options_result.thrift_spec = (
  (0, TType.MAP, 'success', (TType.STRING,True,TType.STRUCT,[InternalOptionInfo, InternalOptionInfo.thrift_spec, False]), None, 2, ), # 0
)

options_result.thrift_struct_annotations = {
}
options_result.thrift_field_annotations = {
}

def options_result__init__(self, success=None,):
  self.success = success

options_result.__init__ = options_result__init__

class registerExtension_args:
  """
  Attributes:
   - info
   - registry
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.info = InternalExtensionInfo()
          self.info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.registry = {}
          (_ktype62, _vtype63, _size61 ) = iprot.readMapBegin() 
          if _size61 >= 0:
            for _i65 in six.moves.range(_size61):
              _key66 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val67 = {}
              (_ktype69, _vtype70, _size68 ) = iprot.readMapBegin() 
              if _size68 >= 0:
                for _i72 in six.moves.range(_size68):
                  _key73 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val74 = []
                  (_etype78, _size75) = iprot.readListBegin()
                  if _size75 >= 0:
                    for _i79 in six.moves.range(_size75):
                      _elem80 = {}
                      (_ktype82, _vtype83, _size81 ) = iprot.readMapBegin() 
                      if _size81 >= 0:
                        for _i85 in six.moves.range(_size81):
                          _key86 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val87 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem80[_key86] = _val87
                      else: 
                        while iprot.peekMap():
                          _key88 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val89 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem80[_key88] = _val89
                      iprot.readMapEnd()
                      _val74.append(_elem80)
                  else: 
                    while iprot.peekList():
                      _elem90 = {}
                      (_ktype92, _vtype93, _size91 ) = iprot.readMapBegin() 
                      if _size91 >= 0:
                        for _i95 in six.moves.range(_size91):
                          _key96 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val97 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem90[_key96] = _val97
                      else: 
                        while iprot.peekMap():
                          _key98 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val99 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem90[_key98] = _val99
                      iprot.readMapEnd()
                      _val74.append(_elem90)
                  iprot.readListEnd()
                  _val67[_key73] = _val74
              else: 
                while iprot.peekMap():
                  _key100 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val101 = []
                  (_etype105, _size102) = iprot.readListBegin()
                  if _size102 >= 0:
                    for _i106 in six.moves.range(_size102):
                      _elem107 = {}
                      (_ktype109, _vtype110, _size108 ) = iprot.readMapBegin() 
                      if _size108 >= 0:
                        for _i112 in six.moves.range(_size108):
                          _key113 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val114 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem107[_key113] = _val114
                      else: 
                        while iprot.peekMap():
                          _key115 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val116 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem107[_key115] = _val116
                      iprot.readMapEnd()
                      _val101.append(_elem107)
                  else: 
                    while iprot.peekList():
                      _elem117 = {}
                      (_ktype119, _vtype120, _size118 ) = iprot.readMapBegin() 
                      if _size118 >= 0:
                        for _i122 in six.moves.range(_size118):
                          _key123 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val124 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem117[_key123] = _val124
                      else: 
                        while iprot.peekMap():
                          _key125 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val126 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem117[_key125] = _val126
                      iprot.readMapEnd()
                      _val101.append(_elem117)
                  iprot.readListEnd()
                  _val67[_key100] = _val101
              iprot.readMapEnd()
              self.registry[_key66] = _val67
          else: 
            while iprot.peekMap():
              _key127 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val128 = {}
              (_ktype130, _vtype131, _size129 ) = iprot.readMapBegin() 
              if _size129 >= 0:
                for _i133 in six.moves.range(_size129):
                  _key134 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val135 = []
                  (_etype139, _size136) = iprot.readListBegin()
                  if _size136 >= 0:
                    for _i140 in six.moves.range(_size136):
                      _elem141 = {}
                      (_ktype143, _vtype144, _size142 ) = iprot.readMapBegin() 
                      if _size142 >= 0:
                        for _i146 in six.moves.range(_size142):
                          _key147 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val148 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem141[_key147] = _val148
                      else: 
                        while iprot.peekMap():
                          _key149 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val150 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem141[_key149] = _val150
                      iprot.readMapEnd()
                      _val135.append(_elem141)
                  else: 
                    while iprot.peekList():
                      _elem151 = {}
                      (_ktype153, _vtype154, _size152 ) = iprot.readMapBegin() 
                      if _size152 >= 0:
                        for _i156 in six.moves.range(_size152):
                          _key157 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val158 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem151[_key157] = _val158
                      else: 
                        while iprot.peekMap():
                          _key159 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val160 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem151[_key159] = _val160
                      iprot.readMapEnd()
                      _val135.append(_elem151)
                  iprot.readListEnd()
                  _val128[_key134] = _val135
              else: 
                while iprot.peekMap():
                  _key161 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val162 = []
                  (_etype166, _size163) = iprot.readListBegin()
                  if _size163 >= 0:
                    for _i167 in six.moves.range(_size163):
                      _elem168 = {}
                      (_ktype170, _vtype171, _size169 ) = iprot.readMapBegin() 
                      if _size169 >= 0:
                        for _i173 in six.moves.range(_size169):
                          _key174 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val175 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem168[_key174] = _val175
                      else: 
                        while iprot.peekMap():
                          _key176 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val177 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem168[_key176] = _val177
                      iprot.readMapEnd()
                      _val162.append(_elem168)
                  else: 
                    while iprot.peekList():
                      _elem178 = {}
                      (_ktype180, _vtype181, _size179 ) = iprot.readMapBegin() 
                      if _size179 >= 0:
                        for _i183 in six.moves.range(_size179):
                          _key184 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val185 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem178[_key184] = _val185
                      else: 
                        while iprot.peekMap():
                          _key186 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _val187 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                          _elem178[_key186] = _val187
                      iprot.readMapEnd()
                      _val162.append(_elem178)
                  iprot.readListEnd()
                  _val128[_key161] = _val162
              iprot.readMapEnd()
              self.registry[_key127] = _val128
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('registerExtension_args')
    if self.info != None:
      oprot.writeFieldBegin('info', TType.STRUCT, 1)
      self.info.write(oprot)
      oprot.writeFieldEnd()
    if self.registry != None:
      oprot.writeFieldBegin('registry', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.registry))
      for kiter188,viter189 in self.registry.items():
        oprot.writeString(kiter188.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter188, bytes) else oprot.writeString(kiter188)
        oprot.writeMapBegin(TType.STRING, TType.LIST, len(viter189))
        for kiter190,viter191 in viter189.items():
          oprot.writeString(kiter190.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter190, bytes) else oprot.writeString(kiter190)
          oprot.writeListBegin(TType.MAP, len(viter191))
          for iter192 in viter191:
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter192))
            for kiter193,viter194 in iter192.items():
              oprot.writeString(kiter193.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter193, bytes) else oprot.writeString(kiter193)
              oprot.writeString(viter194.encode('utf-8')) if UTF8STRINGS and not isinstance(viter194, bytes) else oprot.writeString(viter194)
            oprot.writeMapEnd()
          oprot.writeListEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.info, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    info=%s' % (value))
    value = pprint.pformat(self.registry, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    registry=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(registerExtension_args)
registerExtension_args.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'info', [InternalExtensionInfo, InternalExtensionInfo.thrift_spec, False], None, 2, ), # 1
  (2, TType.MAP, 'registry', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.LIST,(TType.MAP,(TType.STRING,True,TType.STRING,True)))), None, 2, ), # 2
)

registerExtension_args.thrift_struct_annotations = {
}
registerExtension_args.thrift_field_annotations = {
}

def registerExtension_args__init__(self, info=None, registry=None,):
  self.info = info
  self.registry = registry

registerExtension_args.__init__ = registerExtension_args__init__

class registerExtension_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ExtensionStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('registerExtension_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(registerExtension_result)
registerExtension_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [ExtensionStatus, ExtensionStatus.thrift_spec, False], None, 2, ), # 0
)

registerExtension_result.thrift_struct_annotations = {
}
registerExtension_result.thrift_field_annotations = {
}

def registerExtension_result__init__(self, success=None,):
  self.success = success

registerExtension_result.__init__ = registerExtension_result__init__

class deregisterExtension_args:
  """
  Attributes:
   - uuid
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.uuid = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('deregisterExtension_args')
    if self.uuid != None:
      oprot.writeFieldBegin('uuid', TType.I64, 1)
      oprot.writeI64(self.uuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.uuid, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    uuid=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(deregisterExtension_args)
deregisterExtension_args.thrift_spec = (
  None, # 0
  (1, TType.I64, 'uuid', None, None, 2, ), # 1
)

deregisterExtension_args.thrift_struct_annotations = {
}
deregisterExtension_args.thrift_field_annotations = {
}

def deregisterExtension_args__init__(self, uuid=None,):
  self.uuid = uuid

deregisterExtension_args.__init__ = deregisterExtension_args__init__

class deregisterExtension_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ExtensionStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('deregisterExtension_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(deregisterExtension_result)
deregisterExtension_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [ExtensionStatus, ExtensionStatus.thrift_spec, False], None, 2, ), # 0
)

deregisterExtension_result.thrift_struct_annotations = {
}
deregisterExtension_result.thrift_field_annotations = {
}

def deregisterExtension_result__init__(self, success=None,):
  self.success = success

deregisterExtension_result.__init__ = deregisterExtension_result__init__

class query_args:
  """
  Attributes:
   - sql
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sql = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('query_args')
    if self.sql != None:
      oprot.writeFieldBegin('sql', TType.STRING, 1)
      oprot.writeString(self.sql.encode('utf-8')) if UTF8STRINGS and not isinstance(self.sql, bytes) else oprot.writeString(self.sql)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.sql, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    sql=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(query_args)
query_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'sql', True, None, 2, ), # 1
)

query_args.thrift_struct_annotations = {
}
query_args.thrift_field_annotations = {
}

def query_args__init__(self, sql=None,):
  self.sql = sql

query_args.__init__ = query_args__init__

class query_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ExtensionResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('query_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(query_result)
query_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [ExtensionResponse, ExtensionResponse.thrift_spec, False], None, 2, ), # 0
)

query_result.thrift_struct_annotations = {
}
query_result.thrift_field_annotations = {
}

def query_result__init__(self, success=None,):
  self.success = success

query_result.__init__ = query_result__init__

class getQueryColumns_args:
  """
  Attributes:
   - sql
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sql = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('getQueryColumns_args')
    if self.sql != None:
      oprot.writeFieldBegin('sql', TType.STRING, 1)
      oprot.writeString(self.sql.encode('utf-8')) if UTF8STRINGS and not isinstance(self.sql, bytes) else oprot.writeString(self.sql)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.sql, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    sql=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(getQueryColumns_args)
getQueryColumns_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'sql', True, None, 2, ), # 1
)

getQueryColumns_args.thrift_struct_annotations = {
}
getQueryColumns_args.thrift_field_annotations = {
}

def getQueryColumns_args__init__(self, sql=None,):
  self.sql = sql

getQueryColumns_args.__init__ = getQueryColumns_args__init__

class getQueryColumns_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocol) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ExtensionResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocol) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('getQueryColumns_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(getQueryColumns_result)
getQueryColumns_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [ExtensionResponse, ExtensionResponse.thrift_spec, False], None, 2, ), # 0
)

getQueryColumns_result.thrift_struct_annotations = {
}
getQueryColumns_result.thrift_field_annotations = {
}

def getQueryColumns_result__init__(self, success=None,):
  self.success = success

getQueryColumns_result.__init__ = getQueryColumns_result__init__

class Client(Extension.Client, Iface):
  def __enter__(self):
    return self

  def __exit__(self, type, value, tb):
    self._iprot.trans.close()
    if self._iprot is not self._oprot:
      self._oprot.trans.close()

  def __init__(self, iprot, oprot=None):
    Extension.Client.__init__(self, iprot, oprot)

  def extensions(self, ):
    self.send_extensions()
    return self.recv_extensions()

  def send_extensions(self, ):
    self._oprot.writeMessageBegin('extensions', TMessageType.CALL, self._seqid)
    args = extensions_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_extensions(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = extensions_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "extensions failed: unknown result");

  def options(self, ):
    self.send_options()
    return self.recv_options()

  def send_options(self, ):
    self._oprot.writeMessageBegin('options', TMessageType.CALL, self._seqid)
    args = options_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_options(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = options_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "options failed: unknown result");

  def registerExtension(self, info=None, registry=None):
    """
    Parameters:
     - info
     - registry
    """
    self.send_registerExtension(info, registry)
    return self.recv_registerExtension()

  def send_registerExtension(self, info=None, registry=None):
    self._oprot.writeMessageBegin('registerExtension', TMessageType.CALL, self._seqid)
    args = registerExtension_args()
    args.info = info
    args.registry = registry
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_registerExtension(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = registerExtension_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "registerExtension failed: unknown result");

  def deregisterExtension(self, uuid=None):
    """
    Parameters:
     - uuid
    """
    self.send_deregisterExtension(uuid)
    return self.recv_deregisterExtension()

  def send_deregisterExtension(self, uuid=None):
    self._oprot.writeMessageBegin('deregisterExtension', TMessageType.CALL, self._seqid)
    args = deregisterExtension_args()
    args.uuid = uuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deregisterExtension(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deregisterExtension_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deregisterExtension failed: unknown result");

  def query(self, sql=None):
    """
    Parameters:
     - sql
    """
    self.send_query(sql)
    return self.recv_query()

  def send_query(self, sql=None):
    self._oprot.writeMessageBegin('query', TMessageType.CALL, self._seqid)
    args = query_args()
    args.sql = sql
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_query(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = query_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "query failed: unknown result");

  def getQueryColumns(self, sql=None):
    """
    Parameters:
     - sql
    """
    self.send_getQueryColumns(sql)
    return self.recv_getQueryColumns()

  def send_getQueryColumns(self, sql=None):
    self._oprot.writeMessageBegin('getQueryColumns', TMessageType.CALL, self._seqid)
    args = getQueryColumns_args()
    args.sql = sql
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getQueryColumns(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getQueryColumns_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getQueryColumns failed: unknown result");


class Processor(Extension.Processor, Iface, TProcessor):
  _onewayMethods = ()

  def __init__(self, handler):
    Extension.Processor.__init__(self, handler)
    self._processMap["extensions"] = Processor.process_extensions
    self._processMap["options"] = Processor.process_options
    self._processMap["registerExtension"] = Processor.process_registerExtension
    self._processMap["deregisterExtension"] = Processor.process_deregisterExtension
    self._processMap["query"] = Processor.process_query
    self._processMap["getQueryColumns"] = Processor.process_getQueryColumns

  def onewayMethods(self):
    l = []
    l.extend(Extension.Processor.onewayMethods(self))
    l.extend(Processor._onewayMethods)
    return tuple(l)

  @process_main()
  def process(self,): pass

  @process_method(extensions_args, oneway=False)
  def process_extensions(self, args, handler_ctx):
    result = extensions_result()
    try:
      result.success = self._handler.extensions()
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'extensions', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(options_args, oneway=False)
  def process_options(self, args, handler_ctx):
    result = options_result()
    try:
      result.success = self._handler.options()
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'options', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(registerExtension_args, oneway=False)
  def process_registerExtension(self, args, handler_ctx):
    result = registerExtension_result()
    try:
      result.success = self._handler.registerExtension(args.info, args.registry)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'registerExtension', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(deregisterExtension_args, oneway=False)
  def process_deregisterExtension(self, args, handler_ctx):
    result = deregisterExtension_result()
    try:
      result.success = self._handler.deregisterExtension(args.uuid)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'deregisterExtension', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(query_args, oneway=False)
  def process_query(self, args, handler_ctx):
    result = query_result()
    try:
      result.success = self._handler.query(args.sql)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'query', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(getQueryColumns_args, oneway=False)
  def process_getQueryColumns(self, args, handler_ctx):
    result = getQueryColumns_result()
    try:
      result.success = self._handler.getQueryColumns(args.sql)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getQueryColumns', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

Iface._processor_type = Processor

class ContextProcessor(Extension.ContextProcessor, ContextIface, TProcessor):
  _onewayMethods = ()

  def __init__(self, handler):
    Extension.ContextProcessor.__init__(self, handler)
    self._processMap["extensions"] = ContextProcessor.process_extensions
    self._processMap["options"] = ContextProcessor.process_options
    self._processMap["registerExtension"] = ContextProcessor.process_registerExtension
    self._processMap["deregisterExtension"] = ContextProcessor.process_deregisterExtension
    self._processMap["query"] = ContextProcessor.process_query
    self._processMap["getQueryColumns"] = ContextProcessor.process_getQueryColumns

  def onewayMethods(self):
    l = []
    l.extend(Extension.ContextProcessor.onewayMethods(self))
    l.extend(ContextProcessor._onewayMethods)
    return tuple(l)

  @process_main()
  def process(self,): pass

  @process_method(extensions_args, oneway=False)
  def process_extensions(self, args, handler_ctx):
    result = extensions_result()
    try:
      result.success = self._handler.extensions(handler_ctx)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'extensions', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(options_args, oneway=False)
  def process_options(self, args, handler_ctx):
    result = options_result()
    try:
      result.success = self._handler.options(handler_ctx)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'options', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(registerExtension_args, oneway=False)
  def process_registerExtension(self, args, handler_ctx):
    result = registerExtension_result()
    try:
      result.success = self._handler.registerExtension(handler_ctx, args.info, args.registry)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'registerExtension', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(deregisterExtension_args, oneway=False)
  def process_deregisterExtension(self, args, handler_ctx):
    result = deregisterExtension_result()
    try:
      result.success = self._handler.deregisterExtension(handler_ctx, args.uuid)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'deregisterExtension', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(query_args, oneway=False)
  def process_query(self, args, handler_ctx):
    result = query_result()
    try:
      result.success = self._handler.query(handler_ctx, args.sql)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'query', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(getQueryColumns_args, oneway=False)
  def process_getQueryColumns(self, args, handler_ctx):
    result = getQueryColumns_result()
    try:
      result.success = self._handler.getQueryColumns(handler_ctx, args.sql)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getQueryColumns', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

ContextIface._processor_type = ContextProcessor

fix_spec(all_structs)
del all_structs

